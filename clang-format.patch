diff --git a/clang/include/clang/Format/Format.h b/clang/include/clang/Format/Format.h
index fcbe0a7..dbffb3e 100644
--- a/clang/include/clang/Format/Format.h
+++ b/clang/include/clang/Format/Format.h
@@ -700,6 +700,32 @@ struct FormatStyle {
     ///   enum X : int { A, B };
     /// \endcode
     BS_WebKit,
+    /// Like ``Allman``, but do not break do/while loop.
+    /// \code
+    ///   try
+    ///   {
+    ///     foo();
+    ///   }
+    ///   catch ()
+    ///   {
+    ///   }
+    ///   void foo()
+    ///   {
+    ///     bar();
+    ///   }
+    ///   class foo
+    ///   {
+    ///   };
+    ///   if (foo())
+    ///   {
+    ///   }
+    ///   else
+    ///   {
+    ///   }
+    ///   do {
+    ///   } while ();
+    /// \endcode
+    BS_Xen,
     /// Configure each individual brace in `BraceWrapping`.
     BS_Custom
   };
@@ -759,6 +785,20 @@ struct FormatStyle {
     ///   }
     /// \endcode
     bool AfterControlStatement;
+    /// Wrap do/while loop.
+    /// \code
+    ///   true:
+    ///   do
+    ///   {
+    ///     foo();
+    ///   } while();
+    ///
+    ///   false:
+    ///   do {
+    ///     foo();
+    ///   } while();
+    /// \endcode
+    bool AfterDoWhileStatement;
     /// Wrap enum definitions.
     /// \code
     ///   true:
@@ -1111,6 +1151,22 @@ struct FormatStyle {
   /// \endcode
   bool Cpp11BracedListStyle;
 
+  /// Only C style /* ... */ comments are to be used.  C++ style // comments
+  /// should not be used.  Multi-word comments should begin with a capital
+  /// letter.  Comments containing a single sentence may end with a full
+  /// stop; comments containing several sentences must have a full stop
+  /// after each sentence.
+  ///
+  /// Multi-line comment blocks should start and end with comment markers on
+  /// separate lines and each line should begin with a leading '*'.
+  ///
+  /// /*
+  ///  * Example, multi-line comment block.
+  ///  *
+  ///  * Note beginning and end markers on separate lines and leading '*'.
+  ///  */
+  bool XenCstyleCommentsOnly;
+
   /// If ``true``, analyze the formatted file for the most common
   /// alignment of ``&`` and ``*``.
   /// Pointer and reference alignment styles are going to be updated according
@@ -1613,6 +1669,16 @@ struct FormatStyle {
   /// \endcode
   bool ReflowComments;
 
+  /// If ``true``, ommit braces in a single statement.
+  /// \code
+  ///    false:                                 true:
+  ///    if ( condition )                       if ( condition )
+  ///    {                              vs.          single_statement();
+  ///        single_statement();
+  ///    }
+  /// \endcode
+  bool SingleStatementWithoutBraces;
+
   /// If ``true``, clang-format will sort ``#includes``.
   /// \code
   ///    false:                                 true:
@@ -1802,6 +1868,14 @@ struct FormatStyle {
   /// \endcode
   bool SpacesInCStyleCastParentheses;
 
+  /// If ``true``, spaces will be inserted after first ``(`` and before
+  /// last ``)`` in loops and condition only.
+  /// \code
+  ///    true:                                  false:
+  ///    if ( (condition) )             vs.     if ((condition))
+  /// \endcode
+  bool SpacesInLoopsAndConditionParenthesesOnly;
+
   /// If ``true``, spaces will be inserted after ``(`` and before ``)``.
   /// \code
   ///    true:                                  false:
@@ -2020,6 +2094,18 @@ FormatStyle getWebKitStyle();
 /// http://www.gnu.org/prep/standards/standards.html
 FormatStyle getGNUStyle();
 
+/// Returns a format style complying with Xen Coding Standards:
+///
+FormatStyle getXenStyle();
+
+/// Returns a format style complying with Libxenlight Coding Standards:
+///
+FormatStyle getLibxlStyle();
+
+/// Returns a format style complying with Linux kernel Coding Standards:
+/// https://www.kernel.org/doc/html/v4.10/process/coding-style.html
+FormatStyle getLinuxStyle();
+
 /// Returns style indicating formatting should be not applied at all.
 FormatStyle getNoStyle();
 
diff --git a/clang/lib/Format/BreakableToken.cpp b/clang/lib/Format/BreakableToken.cpp
index 72886ed..230aeed 100644
--- a/clang/lib/Format/BreakableToken.cpp
+++ b/clang/lib/Format/BreakableToken.cpp
@@ -388,6 +388,15 @@ BreakableBlockComment::BreakableBlockComment(
       Decoration = Decoration.substr(0, Decoration.size() - 1);
   }
 
+  bool DecorationInserted = false;
+  if (Style.XenCstyleCommentsOnly && Tok.IsMultiline) {
+    DelimitersOnNewline = true;
+    if (Decoration.empty()) {
+      Decoration = "* ";
+      DecorationInserted = true;
+    }
+  }
+
   LastLineNeedsDecoration = true;
   IndentAtLineBreak = ContentColumn[0] + 1;
   for (size_t i = 1, e = Lines.size(); i < e; ++i) {
@@ -405,6 +414,9 @@ BreakableBlockComment::BreakableBlockComment(
         // For all other lines, set the start column to 0 if they're empty, so
         // we do not insert trailing whitespace anywhere.
         ContentColumn[i] = 0;
+      } else if (Style.XenCstyleCommentsOnly && DecorationInserted) {
+        Content[i].trim(Blanks);
+        ContentColumn[i] = ContentColumn[0];
       }
       continue;
     }
@@ -419,7 +431,9 @@ BreakableBlockComment::BreakableBlockComment(
     if (DecorationSize) {
       ContentColumn[i] = DecorationColumn + DecorationSize;
     }
-    Content[i] = Content[i].substr(DecorationSize);
+    if (!DecorationInserted) {
+      Content[i] = Content[i].substr(DecorationSize);
+    }
     if (!Decoration.startswith(Content[i]))
       IndentAtLineBreak =
           std::min<int>(IndentAtLineBreak, std::max(0, ContentColumn[i]));
diff --git a/clang/lib/Format/Format.cpp b/clang/lib/Format/Format.cpp
index 2772db0..2962be9 100644
--- a/clang/lib/Format/Format.cpp
+++ b/clang/lib/Format/Format.cpp
@@ -157,6 +157,7 @@ template <> struct ScalarEnumerationTraits<FormatStyle::BraceBreakingStyle> {
     IO.enumCase(Value, "Allman", FormatStyle::BS_Allman);
     IO.enumCase(Value, "GNU", FormatStyle::BS_GNU);
     IO.enumCase(Value, "WebKit", FormatStyle::BS_WebKit);
+    IO.enumCase(Value, "Xen", FormatStyle::BS_Xen);
     IO.enumCase(Value, "Custom", FormatStyle::BS_Custom);
   }
 };
@@ -302,7 +303,8 @@ template <> struct MappingTraits<FormatStyle> {
 
     if (IO.outputting()) {
       StringRef StylesArray[] = {"LLVM",   "Google", "Chromium", "Mozilla",
-                                 "WebKit", "GNU",    "Microsoft"};
+                                 "WebKit", "GNU",    "Microsoft", "Xen",
+                                 "Libxenlight", "Linux"};
       ArrayRef<StringRef> Styles(StylesArray);
       for (size_t i = 0, e = Styles.size(); i < e; ++i) {
         StringRef StyleName(Styles[i]);
@@ -475,6 +477,8 @@ template <> struct MappingTraits<FormatStyle> {
     IO.mapOptional("PointerAlignment", Style.PointerAlignment);
     IO.mapOptional("RawStringFormats", Style.RawStringFormats);
     IO.mapOptional("ReflowComments", Style.ReflowComments);
+    IO.mapOptional("SingleStatementWithoutBraces",
+                   Style.SingleStatementWithoutBraces);
     IO.mapOptional("SortIncludes", Style.SortIncludes);
     IO.mapOptional("SortUsingDeclarations", Style.SortUsingDeclarations);
     IO.mapOptional("SpaceAfterCStyleCast", Style.SpaceAfterCStyleCast);
@@ -500,12 +504,15 @@ template <> struct MappingTraits<FormatStyle> {
                    Style.SpacesInContainerLiterals);
     IO.mapOptional("SpacesInCStyleCastParentheses",
                    Style.SpacesInCStyleCastParentheses);
+    IO.mapOptional("SpacesInLoopsAndConditionParenthesesOnly",
+                   Style.SpacesInLoopsAndConditionParenthesesOnly);
     IO.mapOptional("SpacesInParentheses", Style.SpacesInParentheses);
     IO.mapOptional("SpacesInSquareBrackets", Style.SpacesInSquareBrackets);
     IO.mapOptional("Standard", Style.Standard);
     IO.mapOptional("StatementMacros", Style.StatementMacros);
     IO.mapOptional("TabWidth", Style.TabWidth);
     IO.mapOptional("UseTab", Style.UseTab);
+    IO.mapOptional("XenCstyleCommentsOnly", Style.XenCstyleCommentsOnly);
   }
 };
 
@@ -514,6 +521,7 @@ template <> struct MappingTraits<FormatStyle::BraceWrappingFlags> {
     IO.mapOptional("AfterCaseLabel", Wrapping.AfterCaseLabel);
     IO.mapOptional("AfterClass", Wrapping.AfterClass);
     IO.mapOptional("AfterControlStatement", Wrapping.AfterControlStatement);
+    IO.mapOptional("AfterDoWhileStatement", Wrapping.AfterDoWhileStatement);
     IO.mapOptional("AfterEnum", Wrapping.AfterEnum);
     IO.mapOptional("AfterFunction", Wrapping.AfterFunction);
     IO.mapOptional("AfterNamespace", Wrapping.AfterNamespace);
@@ -605,7 +613,7 @@ static FormatStyle expandPresets(const FormatStyle &Style) {
     return Style;
   FormatStyle Expanded = Style;
   Expanded.BraceWrapping = {false, false, false, false, false, false,
-                            false, false, false, false, false,
+                            false, false, false, false, false, false,
                             false, false, true,  true,  true};
   switch (Style.BreakBeforeBraces) {
   case FormatStyle::BS_Linux:
@@ -632,6 +640,7 @@ static FormatStyle expandPresets(const FormatStyle &Style) {
     Expanded.BraceWrapping.AfterCaseLabel = true;
     Expanded.BraceWrapping.AfterClass = true;
     Expanded.BraceWrapping.AfterControlStatement = true;
+    Expanded.BraceWrapping.AfterDoWhileStatement = true;
     Expanded.BraceWrapping.AfterEnum = true;
     Expanded.BraceWrapping.AfterFunction = true;
     Expanded.BraceWrapping.AfterNamespace = true;
@@ -642,9 +651,24 @@ static FormatStyle expandPresets(const FormatStyle &Style) {
     Expanded.BraceWrapping.BeforeElse = true;
     break;
   case FormatStyle::BS_GNU:
-    Expanded.BraceWrapping = {true, true, true, true, true, true, true, true,
+    Expanded.BraceWrapping = {true, true, true, true, true, true, true, true, true,
                               true, true, true, true, true, true, true, true};
     break;
+  case FormatStyle::BS_Xen:
+    Expanded.BraceWrapping.AfterCaseLabel = true;
+    Expanded.BraceWrapping.AfterClass = true;
+    Expanded.BraceWrapping.AfterControlStatement = true;
+    Expanded.BraceWrapping.AfterDoWhileStatement = false;
+    Expanded.BraceWrapping.AfterEnum = true;
+    Expanded.BraceWrapping.AfterFunction = true;
+    Expanded.BraceWrapping.AfterNamespace = true;
+    Expanded.BraceWrapping.AfterObjCDeclaration = true;
+    Expanded.BraceWrapping.AfterStruct = true;
+    Expanded.BraceWrapping.AfterExternBlock = true;
+    Expanded.BraceWrapping.BeforeCatch = true;
+    Expanded.BraceWrapping.BeforeElse = true;
+    Expanded.BraceWrapping.IndentBraces = false;
+    break;
   case FormatStyle::BS_WebKit:
     Expanded.BraceWrapping.AfterFunction = true;
     break;
@@ -683,7 +707,7 @@ FormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {
   LLVMStyle.BreakBeforeTernaryOperators = true;
   LLVMStyle.BreakBeforeBraces = FormatStyle::BS_Attach;
   LLVMStyle.BraceWrapping = {false, false, false, false, false, false,
-                             false, false, false, false, false,
+                             false, false, false, false, false, false,
                              false, false, true,  true,  true};
   LLVMStyle.BreakAfterJavaFieldAnnotations = false;
   LLVMStyle.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;
@@ -727,6 +751,8 @@ FormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {
   LLVMStyle.Standard = FormatStyle::LS_Cpp11;
   LLVMStyle.UseTab = FormatStyle::UT_Never;
   LLVMStyle.ReflowComments = true;
+  LLVMStyle.SingleStatementWithoutBraces = false;
+  LLVMStyle.SpacesInLoopsAndConditionParenthesesOnly = false;
   LLVMStyle.SpacesInParentheses = false;
   LLVMStyle.SpacesInSquareBrackets = false;
   LLVMStyle.SpaceInEmptyParentheses = false;
@@ -757,6 +783,7 @@ FormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {
   LLVMStyle.SortUsingDeclarations = true;
   LLVMStyle.StatementMacros.push_back("Q_UNUSED");
   LLVMStyle.StatementMacros.push_back("QT_REQUIRE_VERSION");
+  LLVMStyle.XenCstyleCommentsOnly = false;
 
   // Defaults that differ when not C++.
   if (Language == FormatStyle::LK_TableGen) {
@@ -1018,6 +1045,107 @@ FormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language) {
   return Style;
 }
 
+FormatStyle getXenStyle() {
+  FormatStyle XenStyle = getLLVMStyle();
+  XenStyle.AccessModifierOffset = 0;
+  XenStyle.AlignEscapedNewlines = FormatStyle::ENAS_Left;
+  XenStyle.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;
+  XenStyle.BinPackArguments = false;
+  XenStyle.BinPackParameters = false;
+  XenStyle.BreakBeforeBraces = FormatStyle::BS_Xen;
+  XenStyle.ForEachMacros.push_back("foreach");
+  XenStyle.ForEachMacros.push_back("item_foreach");
+  XenStyle.ForEachMacros.push_back("hash_vcpu_foreach");
+  XenStyle.ForEachMacros.push_back("hash_domain_foreach");
+  XenStyle.ForEachMacros.push_back("foreach_pinned_shadow");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_entry_rcu");
+  XenStyle.ForEachMacros.push_back("hlist_for_each");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_safe");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_entry");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_entry_from");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_entry_safe");
+  XenStyle.ForEachMacros.push_back("hlist_for_each_entry_continue");
+  XenStyle.ForEachMacros.push_back("for_each_cpu");
+  XenStyle.ForEachMacros.push_back("for_each_possible_cpu");
+  XenStyle.ForEachMacros.push_back("for_each_online_cpu");
+  XenStyle.ForEachMacros.push_back("for_each_present_cpu");
+  XenStyle.ForEachMacros.push_back("for_each_set_bit");
+  XenStyle.ForEachMacros.push_back("ebitmap_for_each_positive_bit");
+  XenStyle.ForEachMacros.push_back("for_each_vcpu");
+  XenStyle.ForEachMacros.push_back("for_each_affinity_balance_step");
+  XenStyle.ForEachMacros.push_back("list_for_each");
+  XenStyle.ForEachMacros.push_back("for_each_kimage_entry");
+  XenStyle.ForEachMacros.push_back("page_list_for_each");
+  XenStyle.ForEachMacros.push_back("list_for_each_entry");
+  XenStyle.ForEachMacros.push_back("list_for_each_safe");
+  XenStyle.ForEachMacros.push_back("dt_for_each_device_node");
+  XenStyle.ForEachMacros.push_back("for_each_domain");
+  XenStyle.ForEachMacros.push_back("for_each_drhd_unit");
+  XenStyle.ForEachMacros.push_back("for_each_rmrr_device");
+  XenStyle.ForEachMacros.push_back("for_each_pdev");
+  XenStyle.ForEachMacros.push_back("for_each_amd_iommu");
+  XenStyle.ForEachMacros.push_back("tapdisk_vbd_for_each_request");
+  XenStyle.ForEachMacros.push_back("tapdisk_vbd_for_each_image");
+  XenStyle.ForEachMacros.push_back("scheduler_for_each_event");
+  XenStyle.ForEachMacros.push_back("for_each_memblk");
+  XenStyle.ForEachMacros.push_back("libxl_for_each_set_bit");
+  XenStyle.IndentWidth = 4;
+  XenStyle.KeepEmptyLinesAtTheStartOfBlocks = false;
+  XenStyle.PointerAlignment = FormatStyle::PAS_Left;
+  XenStyle.SingleStatementWithoutBraces = true;
+  XenStyle.SortIncludes = false;
+  XenStyle.SortUsingDeclarations = false;
+  XenStyle.SpacesInContainerLiterals = false;
+  XenStyle.SpaceAfterTemplateKeyword = false;
+  XenStyle.SpaceBeforeCtorInitializerColon = false;
+  XenStyle.SpaceBeforeInheritanceColon = false;
+  XenStyle.SpaceBeforeRangeBasedForLoopColon = false;
+  XenStyle.SpacesInLoopsAndConditionParenthesesOnly = true;
+  XenStyle.TabWidth = 4;
+  XenStyle.XenCstyleCommentsOnly = true;
+  return XenStyle;
+}
+
+FormatStyle getLibxlStyle() {
+  FormatStyle LibxlStyle = getLLVMStyle();
+  LibxlStyle.AccessModifierOffset = 0;
+  LibxlStyle.AlignEscapedNewlines = FormatStyle::ENAS_Left;
+  LibxlStyle.AllowAllParametersOfDeclarationOnNextLine = false;
+  LibxlStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Always;
+  LibxlStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;
+  LibxlStyle.BreakBeforeBraces = FormatStyle::BS_Linux;
+  LibxlStyle.ConstructorInitializerIndentWidth = 4;
+  LibxlStyle.ContinuationIndentWidth = 4;
+  LibxlStyle.IndentWidth = 4;
+  LibxlStyle.KeepEmptyLinesAtTheStartOfBlocks = false;
+  LibxlStyle.SortIncludes = false;
+  LibxlStyle.SortUsingDeclarations = false;
+  LibxlStyle.SpacesInContainerLiterals = false;
+  LibxlStyle.Standard = FormatStyle::LS_Cpp03;
+  LibxlStyle.TabWidth = 4;
+  return LibxlStyle;
+}
+
+FormatStyle getLinuxStyle() {
+  FormatStyle LinuxStyle = getLLVMStyle();
+  LinuxStyle.AccessModifierOffset = 0;
+  LinuxStyle.AlignEscapedNewlines = FormatStyle::ENAS_Left;
+  LinuxStyle.AllowAllParametersOfDeclarationOnNextLine = false;
+  LinuxStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;
+  LinuxStyle.BreakBeforeBraces = FormatStyle::BS_Linux;
+  LinuxStyle.ConstructorInitializerIndentWidth = 8;
+  LinuxStyle.ContinuationIndentWidth = 8;
+  LinuxStyle.IndentWidth = 8;
+  LinuxStyle.KeepEmptyLinesAtTheStartOfBlocks = false;
+  LinuxStyle.SortIncludes = false;
+  LinuxStyle.SortUsingDeclarations = false;
+  LinuxStyle.SpacesInContainerLiterals = false;
+  LinuxStyle.Standard = FormatStyle::LS_Cpp03;
+  LinuxStyle.TabWidth = 8;
+  LinuxStyle.UseTab = FormatStyle::UT_Always;
+  return LinuxStyle;
+}
+
 FormatStyle getNoStyle() {
   FormatStyle NoStyle = getLLVMStyle();
   NoStyle.DisableFormat = true;
@@ -1042,6 +1170,12 @@ bool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,
     *Style = getGNUStyle();
   } else if (Name.equals_lower("microsoft")) {
     *Style = getMicrosoftStyle(Language);
+  } else if (Name.equals_lower("xen")) {
+    *Style = getXenStyle();
+  } else if (Name.equals_lower("libxl")) {
+    *Style = getLibxlStyle();
+  } else if (Name.equals_lower("linux")) {
+    *Style = getLinuxStyle();
   } else if (Name.equals_lower("none")) {
     *Style = getNoStyle();
   } else {
@@ -1572,6 +1706,69 @@ private:
   std::set<FormatToken *, FormatTokenLess> DeletedTokens;
 };
 
+class SingleStatementCleaner : public TokenAnalyzer {
+public:
+  SingleStatementCleaner(const Environment &Env, const FormatStyle &Style)
+      : TokenAnalyzer(Env, Style) {}
+
+  std::pair<tooling::Replacements, unsigned>
+  analyze(TokenAnnotator &Annotator,
+          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,
+          FormatTokenLexer &Tokens) override {
+
+    AffectedRangeMgr.computeAffectedLines(AnnotatedLines);
+    tooling::Replacements Fixes;
+    checkSingleStatement(AnnotatedLines, Fixes);
+
+    for (unsigned i = 0, e = DeletedLines.size(); i != e; ++i) {
+      auto Err = Fixes.add(tooling::Replacement(
+          Env.getSourceManager(),
+          AnnotatedLines[DeletedLines[i]]->First->Tok.getLocation(), 2, ""));
+      if (Err) {
+        llvm::errs() << llvm::toString(std::move(Err)) << "\n";
+        assert(false);
+      }
+    }
+    return {Fixes, 0};
+  }
+
+private:
+  void checkSingleStatement(SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,
+                            tooling::Replacements &Fixes) {
+    for (unsigned i = 0, e = AnnotatedLines.size(); i != e; ++i) {
+      auto &Line = *AnnotatedLines[i];
+      if (Line.startsWith(tok::kw_if) || Line.startsWith(tok::kw_for) ||
+          Line.startsWith(tok::kw_while)) {
+        checkSingleStatement(AnnotatedLines, i, i, Fixes);
+      }
+    }
+  }
+
+  bool checkSingleStatement(SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,
+                            unsigned CurrentLine, unsigned &NewLine,
+                            tooling::Replacements &Fixes) {
+    unsigned End = AnnotatedLines.size();
+    if (Style.BraceWrapping.AfterControlStatement &&
+        AnnotatedLines[++CurrentLine]->startsWith(tok::kw_return)) {
+      NewLine = CurrentLine;
+      return true;
+    } else if (++CurrentLine < End &&
+               AnnotatedLines[CurrentLine - 1]->startsWith(tok::l_brace) &&
+               AnnotatedLines[CurrentLine + 1]->startsWith(tok::r_brace)) {
+      DeletedLines.push_back(CurrentLine - 1);
+      DeletedLines.push_back(CurrentLine + 1);
+
+      NewLine = CurrentLine;
+      return true;
+    }
+
+    NewLine = CurrentLine;
+    return false;
+  }
+
+  std::vector<unsigned> DeletedLines;
+};
+
 class ObjCHeaderStyleGuesser : public TokenAnalyzer {
 public:
   ObjCHeaderStyleGuesser(const Environment &Env, const FormatStyle &Style)
@@ -2271,6 +2468,11 @@ reformat(const FormatStyle &Style, StringRef Code,
       Passes.emplace_back([&](const Environment &Env) {
         return UsingDeclarationsSorter(Env, Expanded).process();
       });
+
+    if (Style.SingleStatementWithoutBraces)
+      Passes.emplace_back([&](const Environment &Env) {
+        return SingleStatementCleaner(Env, Expanded).process();
+      });
   }
 
   if (Style.Language == FormatStyle::LK_JavaScript &&
@@ -2377,7 +2579,8 @@ LangOptions getFormattingLangOpts(const FormatStyle &Style) {
 
 const char *StyleOptionHelpDescription =
     "Coding style, currently supports:\n"
-    "  LLVM, Google, Chromium, Mozilla, WebKit.\n"
+    "  LLVM, Google, Chromium, Mozilla, WebKit,\n"
+    "  Xen, Libxenlight, Linux.\n"
     "Use -style=file to load style configuration from\n"
     ".clang-format file located in one of the parent\n"
     "directories of the source file (or current\n"
diff --git a/clang/lib/Format/TokenAnnotator.cpp b/clang/lib/Format/TokenAnnotator.cpp
index 4e25570..0724fa9 100644
--- a/clang/lib/Format/TokenAnnotator.cpp
+++ b/clang/lib/Format/TokenAnnotator.cpp
@@ -2478,11 +2478,18 @@ bool TokenAnnotator::spaceRequiredBetween(const AnnotatedLine &Line,
     return Right.is(tok::hash);
   if (Left.is(tok::l_paren) && Right.is(tok::r_paren))
     return Style.SpaceInEmptyParentheses;
-  if (Left.is(tok::l_paren) || Right.is(tok::r_paren))
-    return (Right.is(TT_CastRParen) ||
-            (Left.MatchingParen && Left.MatchingParen->is(TT_CastRParen)))
-               ? Style.SpacesInCStyleCastParentheses
-               : Style.SpacesInParentheses;
+  if (Left.is(tok::l_paren) || Right.is(tok::r_paren)) {
+    if (Right.is(TT_CastRParen) || ((Left.MatchingParen &&
+                                    Left.MatchingParen->is(TT_CastRParen))))
+      return Style.SpacesInCStyleCastParentheses;
+    else
+      return (Left.Previous &&
+        Left.Previous->isOneOf(tok::kw_if, tok::kw_for, tok::kw_while)) ||
+        (Right.MatchingParen && Right.MatchingParen->Previous &&
+         Right.MatchingParen->Previous->isOneOf(tok::kw_if, tok::kw_for, tok::kw_while))
+          ? Style.SpacesInLoopsAndConditionParenthesesOnly
+          : Style.SpacesInParentheses;
+  }
   if (Right.isOneOf(tok::semi, tok::comma))
     return false;
   if (Right.is(tok::less) && Line.Type == LT_ObjCDecl) {
@@ -2900,6 +2907,7 @@ bool TokenAnnotator::spaceRequiredBefore(const AnnotatedLine &Line,
     return false;
   if (Left.is(TT_RegexLiteral))
     return false;
+
   return spaceRequiredBetween(Line, Left, Right);
 }
 
diff --git a/clang/lib/Format/UnwrappedLineParser.cpp b/clang/lib/Format/UnwrappedLineParser.cpp
index 7acf33a..82bd9f6 100644
--- a/clang/lib/Format/UnwrappedLineParser.cpp
+++ b/clang/lib/Format/UnwrappedLineParser.cpp
@@ -1934,7 +1934,8 @@ void UnwrappedLineParser::parseDoWhile() {
   assert(FormatTok->Tok.is(tok::kw_do) && "'do' expected");
   nextToken();
   if (FormatTok->Tok.is(tok::l_brace)) {
-    CompoundStatementIndenter Indenter(this, Style, Line->Level);
+    if (Style.BraceWrapping.AfterDoWhileStatement)
+      CompoundStatementIndenter Indenter(this, Style, Line->Level);
     parseBlock(/*MustBeDeclaration=*/false);
     if (Style.BraceWrapping.IndentBraces)
       addUnwrappedLine();
